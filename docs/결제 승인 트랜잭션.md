## 1. 개요
프로젝트의 결제 승인 로직에서 `block()` 호출과 트랜잭션 전파 정책이 왜 충돌할 수 있는지 설명하고, 현재 코드에서 `Propagation.SUPPORTS`를 선택한 이유와 한계를 정리한다.



## 2. 현재 코드 상황
다음 코드에서는 클래스 레벨에 `@Transactional`이 선언되어 있다.

```java
@Service
@Transactional
public class PaymentService { ... }
```

결제 승인 메서드는 외부 결제 API를 `WebClient`로 호출하고, 응답 수신 시 `.block()`을 사용한다.

```java
TossConfirmResponseDto response = tossWebClient.post()
        .uri("/v1/payments/confirm")
        .bodyValue(body)
        .retrieve()
        .bodyToMono(TossConfirmResponseDto.class)
        .block();
```

즉, 메서드에 동기 대기 구간이 있다.

## 3. 왜 문제가 될 수 있을까?
`block()` 자체가 항상 잘못은 아니지만, 트랜잭션 내부에서 외부 네트워크 I/O를 오래 기다리면 다음 문제가 생길 수 있다.

1. 트랜잭션 점유 시간 증가  
DB 커넥션과 트랜잭션 컨텍스트를 오래 잡을 가능성이 커진다.

2. 동시성 처리량 저하  
외부 API 지연이 내부 스레드/커넥션 점유 시간으로 전파된다.

3. 실패 전파 범위 확대  
외부 API 문제(타임아웃/지연)가 트랜잭션 경계 전체의 지연으로 이어질 수 있다.

## 4. 전파 옵션 정리
### 4.1 REQUIRED
- 기본값
- 기존 트랜잭션이 있으면 참여, 없으면 새 트랜잭션 생성

### 4.2 SUPPORTS
- 기존 트랜잭션이 있으면 참여
- 기존 트랜잭션이 없으면 트랜잭션 없이 실행

### 4.3 NOT_SUPPORTED
- 기존 트랜잭션이 있으면 중단(suspend)
- 항상 트랜잭션 없이 실행

### 4.4 REQUIRES_NEW
- 기존 트랜잭션과 분리해 새 트랜잭션을 강제로 시작

## 5. 해당 상황에서의 선택: SUPPORTS
적용 내용:

```java
@Transactional(propagation = Propagation.SUPPORTS)
public TossConfirmResponseDto confirmPayment(...) { ... }
```

선택 이유:

1. 일반적인 컨트롤러 호출 경로에서 상위 트랜잭션이 없으면, `confirmPayment`는 트랜잭션 없이 실행된다.  
2. 기존 트랜잭션 문맥에서 호출될 경우에는 흐름을 깨지 않고 참여한다.  
3. `NOT_SUPPORTED` 대비 테스트/호출 정합성을 유지하기 쉽다.

## 6. NOT_SUPPORTED를 바로 채택하지 않은 이유
검증 과정에서 `NOT_SUPPORTED` 적용 시 테스트 트랜잭션과 충돌이 발생했다.

대표 증상:
- 같은 테스트 트랜잭션 안에서 생성한 결제 데이터가 조회되지 않아 `NotFoundException` 발생

원인 요약:
- `NOT_SUPPORTED`는 기존 트랜잭션을 중단한 뒤 별도 비트랜잭션 문맥에서 실행된다.
- 테스트 데이터가 아직 커밋되지 않은 경우, 비트랜잭션 조회에서 보이지 않을 수 있다.

## 7. SUPPORTS의 한계
`SUPPORTS`는 절충안이다. 아래 한계가 남는다.

1. 상위 트랜잭션이 이미 존재하면 그대로 참여한다.  
2. 따라서 특정 호출 경로에서는 여전히 트랜잭션 내부에서 `block()`이 발생할 수 있다.  
3. 근본 해결은 "외부 API 대기 구간"과 "DB 반영 구간”" 경계를 구조적으로 분리하는 것이다.

## 8. 중장기 권장 개선 방향
### 8.1 외부 호출과 DB 갱신 분리
아래처럼 책임을 분리하면 트랜잭션 경계를 명시적으로 제어하기 쉽다.

1. 외부 API 호출 메서드: **비트랜잭션**  
2. 결과 반영 메서드: **트랜잭션**

### 8.2 트랜잭션 구간 최소화
외부 API 응답 수신 후, 필요한 DB 반영 구간만 짧게 트랜잭션을 열어 처리한다.

### 8.3 타임아웃/재시도 정책 명시
외부 결제 승인 호출은 타임아웃, 재시도, 실패 로그 정책을 명확히 유지해야 한다.

## 9. 체크리스트
1. 외부 I/O(`HTTP`, `MQ`, `gRPC`)가 트랜잭션 내부에서 대기하지 않는가  
2. 메서드 반환 타입과 실제 처리 방식(동기/비동기)이 일치하는가  
3. 트랜잭션 전파 설정이 호출 경로별로 의도와 맞는가  
4. 승인 실패 시 상태 전이(`READY -> ABORTED`)가 일관적인가  
5. 외부 API 지연 시 시스템 자원(스레드/커넥션) 점유가 과도하지 않은가

## 10. 결론
현재 `SUPPORTS` 적용은 "운영 리스크를 낮추면서 기존 흐름을 크게 깨지 않는" 현실적 선택이다.  
다만 `block()`과 트랜잭션의 구조적 분리는 아직 남은 과제로, 향후 외부 호출과 DB 반영 경계를 분리하는 리팩터링이 필요하다.
