Jenkins와 GitHub Actions는 둘 다 성숙한 CI/CD 도구지만, 철학, 운영모델, 비용 구조가 꽤 다르다. 특히 "온프레미스/독립 인프라를 얼마나 쥐고 가고 싶은지"와 "깃허브 락인 수용 여부"가 선택의 핵심 축이 된다.

## 개념·아키텍처 차이

- Jenkins  
  - 오픈소스 **자동화 서버**로, JVM 위에서 돌아가는 중앙 서버(마스터/컨트롤러) + 에이전트 구조를 갖는다.
  - 수천 개에 달하는 플러그인 생태계를 통해 거의 모든 SCM, 이슈 트래커, 클라우드, 빌드툴과 연동 가능하지만, 그만큼 플러그인 호환성·업그레이드 관리 부담이 크다.
- GitHub Actions  
  - GitHub에 내장된 **이벤트 기반 CI/CD 플랫폼**으로, 리포지토리 이벤트(push, PR, release 등)에 반응하는 워크플로를 YAML로 정의한다.
  - GitHub가 호스팅하는 러너와 자체 호스팅 러너 둘 다 지원하며, “액션” 마켓플레이스로 재사용 가능한 스텝을 공유한다.

정리하면 Jenkins는 "어디서나 돌아가는 범용 자동화 서버", GitHub Actions는 "GitHub에 강하게 붙어 있는 관리형 CI/CD 레이어"에 가깝다.

## 기능·생태계 비교

| 항목 | Jenkins | GitHub Actions |
| --- | --- | --- |
| 구성 방식 | Scripted/Declarative Pipeline(Jenkinsfile) Groovy DSL 기반 | `.github/workflows/*.yml` YAML 기반 워크플로우 |
| 트리거 | SCM 웹훅, cron, 수동, 외부 시스템 등 폭넓은 트리거 | GitHub 이벤트(push, PR, issue, release 등)에 강하게 최적화 |
| 호스팅 | 기본은 직접 설치/운영. VM, 온프레미스, 쿠버네티스 등 어디든 배포 가능 | GitHub 호스티드 러너 + 셀프 호스티드 러너(온프레미스/클라우드) 선택|
| 확장성 | 플러그인 기반으로 대부분의 툴 연동 가능하지만, 플러그인 지옥 문제가 자주 언급됨 | 2만+ 액션을 제공하는 마켓플레이스로 통합된 느낌의 확장성 제공 |
| UI/UX | 전통적인 UI, 설정이 복잡하고 Job이 많아지면 관리 난이도 급상승 | 리포지토리 탭 내에서 빌드 상태, 로그, 아티팩트, 배포까지 시각화 |
| 권한/보안 | 자체 LDAP/SSO/Role 구성, 네트워크 세그먼트/프록시 뒤에 둘 수 있어 규제 환경에 유리 | GitHub 권한 모델과 통합. 브랜치 보호, 환경 승인, 시크릿 스토리지 연계. 특히 AWS/GCP 연동 시 키 발급 없이 인증하는 OIDC(OpenID Connect)가 기본 지원되어 보안 규정 준수에 유리|

개발자 경험 차이:
- Jenkins: 빌드 실패 시 해당 노드에 SSH로 접속하거나, 웹에서 스크립트만 수정해 즉시 다시 돌려보는 Replay 기능이 강력하여 디버깅이 직관적이다.

- GitHub Actions: 로컬 시뮬레이션(act)이나 반복적인 커밋(fix ci)으로 디버깅해야 하는 번거로움이 있었으나, 최근 디버그 모드 지원으로 개선되고 있다.

CI/CD 기능 자체는 둘 다 빌드·테스트·배포·아티팩트 다루기에 충분하지만, **Jenkins는 유연성과 범용성**, Actions는 **GitHub와의 일체감과 간결함**에서 강점을 가진다.

## 운영·확장·신뢰성

### Jenkins

- 장점  
  - 어디에나 설치 가능해서 온프레미스, 에어갭 환경, 자체 VPC 환경에서 완전히 통제된 CI/CD를 구축하기 좋다.
  - 컨트롤러/에이전트 아키텍처로 빌드 노드를 수평 확장할 수 있고, 여러 컨트롤러를 제품 라인별로 나누는 패턴도 공식 문서에서 제안한다.
  - 빌드 노드가 상태를 유지(Stateful)하므로, 이전 빌드의 캐시나 작업물을 그대로 활용하는 Incremental Build 구성에 유리하다.
- 단점  
  - 단일 서버 아키텍처를 기본으로 하기 때문에, 대규모 환경에서는 컨트롤러 스케일링 전략을 별도로 설계해야 하고, 잘못 설계하면 빌드 대기열과 성능 병목이 쉽게 발생한다.
  - 플러그인 호환성, 마스터 업그레이드, 백업/복구, 보안 패치 등 운영 부담이 상당하며, 이 때문에 대규모 환경에서 점점 대체하려는 움직임이 많다.

### GitHub Actions

- 장점  
  - GitHub가 컨트롤 플레인과 호스티드 러너를 운영하므로, 사용자는 YAML과 러너 설정만 관리하면 된다.
  - 매트릭스 빌드, 병렬 잡, 재사용 워크플로 등 현대적인 파이프라인 기능이 기본 지원되고, 클라우드 서비스 배포 액션이 풍부하다.
  - 호스티드 러너는 일회성 VM이라 매번 깨끗한 환경에서 빌드하므로, 환경 오염으로 인한 빌드 실패(Dirty Build) 가능성이 원천 차단된다.
- 단점  
  - GitHub 다운타임/제한에 직접 영향을 받으며, Actions를 쓰려면 기본적으로 소스 코드가 GitHub에 있어야 한다.
  - 셀프 호스티드 러너를 쓰더라도 컨트롤 플레인(오케스트레이션)은 GitHub에 종속된다.

운영 부담을 최소화하고 싶다면 GitHub Actions, CI 컨트롤도 온전히 조직 내부에 두고 싶다면 Jenkins 쪽에 무게가 실린다.

## 비용·라이선스

- Jenkins  
  - 소프트웨어 자체는 완전 무료(오픈소스)지만, 서버/스토리지/네트워크 비용과 운영 인건비를 온전히 팀이 부담한다.
  - 빌드 노드를 가로로 많이 늘릴수록 인프라 비용이 증가하지만, CI 사용량이 매우 큰 대기업에서는 '고정비 + 자체 최적화' 전략으로 장기적으로 유리할 수 있다.
- GitHub Actions  
  - GitHub 호스티드 러너는 분 단위 과금이며, GitHub 플랜마다 무료 분이 제공된다.
  - 셀프 호스티드 러너는 과거에는 컨트롤 플레인 비용이 사실상 0에 가까웠으나, 한때 GitHub가 셀프 호스티드 러너에도 공통 플랫폼 과금을 검토한다는 논의가 있었으나, 현재 기준으로는 공식적으로 확정된 정책은 없다.
  - 요약하면, 퍼블릭 리포지토리나 소규모 팀은 대부분 무료 구간 안에서 해결되지만, 대규모 CI 워크로드를 Actions에 몰아넣으면 런타임 비용이 높을 수 있다.

즉, **소규모/중소규모 GitHub 중심 조직**은 Actions가 비용·생산성 측면에서 이득이고, **매우 큰 조직·온프레미스 규제 환경**에서는 Jenkins(혹은 Jenkins 계열을 포함한 자체 호스팅 CI 플랫폼)가 더 경제적일 수 있다.

## 언제 무엇을 선택할까

### Jenkins가 더 적합한 경우

- 소스 코드가 GitHub에 있지 않거나, 여러 SCM(자체 Git, Bitbucket, GitLab 등)을 한 CI에서 다뤄야 할 때
- 온프레미스/폐쇄망/규제 산업 환경에서 CI/CD 인프라와 데이터 경로를 100% 조직 내부에 유지해야 할 때
- 팀에 인프라·DevOps 전문 인력이 있고, 플러그인/잡/클러스터를 장기적으로 관리할 수 있을 때

### GitHub Actions가 더 적합한 경우

- 코드 호스팅을 이미 GitHub로 통일했고, PR 기반 개발 프로세스를 강하게 쓰는 조직
- Jenkins 서버 운영/백업/보안패치/플러그인 관리에 시간을 쓰기 싫고, YAML만으로 파이프라인 정의 + 관리형 CI를 원하는 팀
- 클라우드 네이티브 서비스(AWS/Azure/GCP 등)에 배포하면서, 각 클라우드용 공식 액션과 마켓플레이스를 적극 활용하고 싶은 경우

실무 관점에서 요약하면, 'GitHub에 올려진 서비스 위주 + 인프라 팀 규모가 크지 않은 조직'은 GitHub Actions를 기본값으로 보고, '레거시 시스템·온프레미스·다양한 SCM을 아우르는 엔터프라이즈 환경'은 Jenkins(또는 Jenkins 대체 CI)를 고려하는 방향이 좋다.